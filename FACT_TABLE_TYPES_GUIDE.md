# Fact Table Types Guide for VES Data Warehouse

**Understanding Transaction, Accumulating Snapshot, Periodic Snapshot, and Factless Fact Tables**

Author: Mark Chappell
Last Updated: 2024-11-18
Difficulty: Intermediate
Reading Time: 30-45 minutes

---

## Table of Contents

- [Overview](#overview)
- [Fact Table Fundamentals](#fact-table-fundamentals)
- [Type 1: Transaction Fact Tables](#type-1-transaction-fact-tables)
- [Type 2: Periodic Snapshot Fact Tables](#type-2-periodic-snapshot-fact-tables)
- [Type 3: Accumulating Snapshot Fact Tables](#type-3-accumulating-snapshot-fact-tables)
- [Type 4: Factless Fact Tables](#type-4-factless-fact-tables)
- [Comparison Matrix](#comparison-matrix)
- [VES Data Warehouse Examples](#ves-data-warehouse-examples)
- [Design Decision Framework](#design-decision-framework)
- [Common Mistakes](#common-mistakes)
- [Best Practices](#best-practices)

---

## Overview

### What is a Fact Table?

A **fact table** is the central table in a star schema that stores **business measurements** (facts) and **foreign keys** to dimension tables. Facts are typically:
- Numeric values (sales amount, quantity, rating)
- Additive (can be summed across dimensions)
- Generated by business processes or events

### The Four Fact Table Types

Different business processes require different fact table patterns:

| Type | Grain | Updates | Use When |
|------|-------|---------|----------|
| **Transaction** | One row per event | Rarely updated | Tracking individual events as they occur |
| **Periodic Snapshot** | One row per period | Regular intervals | Tracking state at regular time intervals |
| **Accumulating Snapshot** | One row per process | Updated through lifecycle | Tracking multi-step processes |
| **Factless** | One row per relationship | Rarely updated | Tracking relationships or coverage |

**Key Question:** What are you measuring?
- **Events** ‚Üí Transaction fact
- **State at a point in time** ‚Üí Periodic snapshot fact
- **Progress through a process** ‚Üí Accumulating snapshot fact
- **Relationships or coverage** ‚Üí Factless fact

---

## Fact Table Fundamentals

### Anatomy of a Fact Table

```sql
CREATE TABLE fact_example (
    -- Surrogate key (optional but recommended)
    example_sk NUMBER(38,0) PRIMARY KEY,

    -- Foreign keys to dimensions (REQUIRED)
    date_sk NUMBER(38,0) NOT NULL,      -- FK to dim_date
    veteran_sk NUMBER(38,0) NOT NULL,   -- FK to dim_veteran
    facility_sk NUMBER(38,0) NOT NULL,  -- FK to dim_facility

    -- Degenerate dimensions (optional)
    transaction_id VARCHAR(50),         -- No separate dimension table

    -- Facts/Measures (the numbers we analyze)
    quantity NUMBER(10,0),              -- Additive
    amount NUMBER(12,2),                -- Additive
    rating NUMBER(3,0),                 -- Non-additive (avg instead)

    -- Audit columns
    row_created_timestamp TIMESTAMP_NTZ
);
```

### Fact Types

1. **Additive Facts** - Can be summed across all dimensions
   - Examples: revenue, quantity, count
   - `SELECT SUM(revenue) ...` ‚úÖ Always valid

2. **Semi-Additive Facts** - Can be summed across some dimensions, not others
   - Examples: account balance, inventory level
   - `SELECT SUM(balance) GROUP BY date` ‚ùå Invalid (double counting)
   - `SELECT SUM(balance) GROUP BY customer` ‚úÖ Valid

3. **Non-Additive Facts** - Cannot be summed
   - Examples: percentages, ratios, averages
   - `SELECT SUM(rating) ...` ‚ùå Meaningless
   - `SELECT AVG(rating) ...` ‚úÖ Valid

---

## Type 1: Transaction Fact Tables

### Definition

**Transaction facts** record individual business events as they occur. Each row represents **one event** at **one point in time**.

### Characteristics

- **Grain**: One row per transaction/event
- **Updates**: Immutable (rarely updated after insert)
- **Growth**: Continuous (new rows added constantly)
- **Queries**: "What happened?" aggregated over time periods

### Key Features

‚úÖ **DO:**
- Insert new row for each event
- Keep historical data indefinitely (or per retention policy)
- Use for event-driven processes

‚ùå **DON'T:**
- Update rows after insert (except corrections)
- Delete historical data without retention policy
- Use for slowly changing state data

### VES Example: fact_evaluation

**Business Process:** Medical evaluation completed

```sql
CREATE TABLE fact_evaluation (
    -- Surrogate key
    evaluation_sk NUMBER(38,0) PRIMARY KEY,

    -- Date/time dimensions
    evaluation_date_sk NUMBER(38,0) NOT NULL,   -- When eval performed

    -- Who/what/where dimensions
    veteran_sk NUMBER(38,0) NOT NULL,
    evaluator_sk NUMBER(38,0) NOT NULL,
    facility_sk NUMBER(38,0) NOT NULL,
    evaluation_type_sk NUMBER(38,0) NOT NULL,
    medical_condition_sk NUMBER(38,0) NOT NULL,

    -- Degenerate dimensions
    evaluation_id VARCHAR(50),                   -- Transaction ID

    -- Facts (measurements)
    evaluation_duration_minutes NUMBER(5,0),     -- Additive
    compensation_amount NUMBER(10,2),            -- Additive
    exam_completeness_score NUMBER(5,2),         -- Non-additive (avg)
    veteran_satisfaction_score NUMBER(3,0),      -- Non-additive (avg)

    -- Flags
    sufficient_exam_flag BOOLEAN,
    dbq_completed_flag BOOLEAN,

    -- Audit
    row_created_timestamp TIMESTAMP_NTZ
);
```

**Sample Data:**
```
evaluation_sk | veteran_sk | evaluation_date | duration_min | compensation
--------------|------------|-----------------|--------------|-------------
1001          | 5001       | 2024-01-15      | 60           | 450.00
1002          | 5002       | 2024-01-15      | 45           | 350.00
1003          | 5001       | 2024-02-10      | 55           | 425.00
```

**Typical Queries:**
```sql
-- How many evaluations per month?
SELECT
    d.fiscal_year,
    d.fiscal_month,
    COUNT(*) AS evaluation_count,
    SUM(duration_minutes) AS total_minutes,
    AVG(veteran_satisfaction_score) AS avg_satisfaction
FROM fact_evaluation f
JOIN dim_date d ON f.evaluation_date_sk = d.date_sk
WHERE d.fiscal_year = 2024
GROUP BY d.fiscal_year, d.fiscal_month
ORDER BY d.fiscal_month;
```

### Other VES Transaction Facts

- `fact_appointment` - One row per scheduled appointment
- `fact_appointment_events` - One row per appointment event (scheduled, rescheduled, cancelled)
- `fact_evaluation_qa_events` - One row per QA review event
- `fact_examiner_assignments` - One row per assignment of evaluator to exam

### When to Use Transaction Facts

‚úÖ **Use when:**
- Events occur at unpredictable intervals
- You need detailed event-level analysis
- Events are independent of each other
- You're tracking "what happened and when"

‚ùå **Don't use when:**
- You need to track progress through stages
- You only care about current state
- Updates are frequent and represent state changes

---

## Type 2: Periodic Snapshot Fact Tables

### Definition

**Periodic snapshot facts** record the state of a business process at **regular, predictable intervals** (daily, weekly, monthly, quarterly).

### Characteristics

- **Grain**: One row per entity per time period
- **Updates**: New row each period (no updates to existing rows)
- **Growth**: Predictable (one row per entity per period)
- **Queries**: "What was the state?" at specific points in time

### Key Features

‚úÖ **DO:**
- Insert at regular intervals (end of day, end of month, etc.)
- Capture semi-additive facts (balances, levels, statuses)
- Use for trend analysis over time

‚ùå **DON'T:**
- Update historical snapshots (insert new instead)
- Use for unpredictable events
- Use when you need event-level detail

### VES Example: fact_daily_snapshot

**Business Process:** Daily operational metrics

```sql
CREATE TABLE fact_daily_snapshot (
    -- Composite key (one row per facility per day)
    snapshot_sk NUMBER(38,0) PRIMARY KEY,

    -- Date dimension (THE KEY TIME DIMENSION)
    snapshot_date_sk NUMBER(38,0) NOT NULL,

    -- Entity dimensions
    facility_sk NUMBER(38,0) NOT NULL,

    -- Point-in-time counts (semi-additive)
    active_veterans_count NUMBER(10,0),          -- Count at end of day
    pending_evaluations_count NUMBER(10,0),      -- Backlog at end of day
    available_evaluators_count NUMBER(5,0),      -- Capacity at end of day
    open_appointments_count NUMBER(10,0),        -- Open slots at end of day

    -- Period aggregates (additive)
    evaluations_completed_today NUMBER(10,0),    -- Count for the day
    appointments_scheduled_today NUMBER(10,0),   -- Count for the day
    total_revenue_today NUMBER(12,2),            -- Sum for the day

    -- Semi-additive facts
    average_wait_time_days NUMBER(5,1),          -- Average at end of day
    capacity_utilization_percent NUMBER(5,2),    -- % at end of day

    -- Audit
    snapshot_taken_timestamp TIMESTAMP_NTZ,
    row_created_timestamp TIMESTAMP_NTZ
);
```

**Sample Data:**
```
snapshot_date | facility_sk | pending_evals | completed_today | capacity_util_%
--------------|-------------|---------------|-----------------|----------------
2024-01-15    | 101         | 45            | 12              | 85.5
2024-01-16    | 101         | 48            | 15              | 90.2
2024-01-17    | 101         | 42            | 18              | 88.7
2024-01-15    | 102         | 30            | 10              | 75.0
2024-01-16    | 102         | 35            | 8               | 70.5
```

**Typical Queries:**
```sql
-- Trend: How has backlog changed over time?
SELECT
    d.full_date,
    f.facility_name,
    s.pending_evaluations_count,
    s.capacity_utilization_percent
FROM fact_daily_snapshot s
JOIN dim_date d ON s.snapshot_date_sk = d.date_sk
JOIN dim_facility f ON s.facility_sk = f.facility_sk
WHERE d.full_date >= CURRENT_DATE() - 30
  AND f.facility_name = 'Buffalo VAMC'
ORDER BY d.full_date;

-- What was the state on a specific date?
SELECT
    f.facility_name,
    s.pending_evaluations_count,
    s.available_evaluators_count,
    s.capacity_utilization_percent
FROM fact_daily_snapshot s
JOIN dim_date d ON s.snapshot_date_sk = d.date_sk
JOIN dim_facility f ON s.facility_sk = f.facility_sk
WHERE d.full_date = '2024-01-15';
```

### When to Use Periodic Snapshots

‚úÖ **Use when:**
- You need to track state at regular intervals
- You're measuring levels, balances, or status
- You need trend analysis ("How did backlog change over time?")
- You need to answer "What was the state on date X?"

‚ùå **Don't use when:**
- Events occur at unpredictable times
- You need event-level detail
- State changes through multiple stages (use accumulating snapshot)

---

## Type 3: Accumulating Snapshot Fact Tables

### Definition

**Accumulating snapshot facts** track a **business process with defined stages** from beginning to end. Each row represents **one instance** of the process and is **updated** as it progresses through stages.

### Characteristics

- **Grain**: One row per process instance (e.g., one claim, one exam request)
- **Updates**: Updated frequently as process moves through stages
- **Growth**: Moderate (one row per process instance ever)
- **Queries**: "How long did each stage take?" and "What's the current status?"

### Key Features

‚úÖ **DO:**
- Use multiple date foreign keys (one per milestone)
- Update rows as milestones are reached
- Calculate lag times between milestones
- Track SLA compliance

‚ùå **DON'T:**
- Use for events that don't have stages
- Use for processes without clear milestones
- Forget to handle null dates for stages not yet reached

### VES Example: fact_exam_requests

**Business Process:** Exam request from submission to completion

**Stages:**
1. Request received
2. Evaluator assigned
3. Appointment scheduled
4. Evaluation completed
5. Report submitted
6. Report approved

```sql
CREATE TABLE fact_exam_requests (
    -- Surrogate key
    exam_request_sk NUMBER(38,0) PRIMARY KEY,

    -- MULTIPLE DATE FOREIGN KEYS (one per milestone)
    request_date_sk NUMBER(38,0) NOT NULL,       -- Stage 1: Request received
    assigned_date_sk NUMBER(38,0),               -- Stage 2: Assigned (NULL if not yet)
    scheduled_date_sk NUMBER(38,0),              -- Stage 3: Scheduled (NULL if not yet)
    completed_date_sk NUMBER(38,0),              -- Stage 4: Completed (NULL if not yet)
    submitted_date_sk NUMBER(38,0),              -- Stage 5: Submitted (NULL if not yet)
    approved_date_sk NUMBER(38,0),               -- Stage 6: Approved (NULL if not yet)

    -- Entity dimensions
    veteran_sk NUMBER(38,0) NOT NULL,
    evaluator_sk NUMBER(38,0),                    -- NULL until assigned
    facility_sk NUMBER(38,0),                     -- NULL until scheduled
    evaluation_type_sk NUMBER(38,0) NOT NULL,
    exam_request_type_sk NUMBER(38,0) NOT NULL,

    -- Degenerate dimension
    exam_request_id VARCHAR(50),

    -- Actual dates (denormalized for easier querying)
    request_date DATE NOT NULL,
    assigned_date DATE,
    scheduled_date DATE,
    appointment_date DATE,
    completed_date DATE,
    submitted_date DATE,
    approved_date DATE,
    cancelled_date DATE,

    -- Current status
    exam_status VARCHAR(50) NOT NULL,             -- Current stage

    -- LAG FACTS (calculated time between milestones)
    days_request_to_assigned NUMBER(5,0),         -- NULL until assigned
    days_assigned_to_scheduled NUMBER(5,0),       -- NULL until scheduled
    days_scheduled_to_completed NUMBER(5,0),      -- NULL until completed
    days_completed_to_submitted NUMBER(5,0),      -- NULL until submitted
    days_submitted_to_approved NUMBER(5,0),       -- NULL until approved
    total_cycle_time_days NUMBER(5,0),            -- NULL until completed

    -- SLA facts
    sla_target_days NUMBER(5,0),
    sla_met BOOLEAN,
    sla_variance_days NUMBER(6,0),                -- Positive = late, Negative = early

    -- Audit
    row_created_timestamp TIMESTAMP_NTZ,
    row_updated_timestamp TIMESTAMP_NTZ
);
```

**Sample Data (showing progression):**

**Time T1 - Request Just Received:**
```
exam_request_sk | request_date | assigned_date | completed_date | exam_status | total_cycle_time
----------------|--------------|---------------|----------------|-------------|------------------
1001            | 2024-01-15   | NULL          | NULL           | REQUESTED   | NULL
```

**Time T2 - Evaluator Assigned:**
```
exam_request_sk | request_date | assigned_date | completed_date | exam_status | days_req_to_assign
----------------|--------------|---------------|----------------|-------------|--------------------
1001            | 2024-01-15   | 2024-01-17    | NULL           | ASSIGNED    | 2
```

**Time T3 - Evaluation Completed:**
```
exam_request_sk | request_date | assigned_date | completed_date | exam_status | total_cycle_time
----------------|--------------|---------------|----------------|-------------|------------------
1001            | 2024-01-15   | 2024-01-17    | 2024-01-25     | COMPLETED   | 10
```

**Typical Queries:**
```sql
-- Average time at each stage
SELECT
    AVG(days_request_to_assigned) AS avg_assignment_time,
    AVG(days_assigned_to_scheduled) AS avg_scheduling_time,
    AVG(days_scheduled_to_completed) AS avg_completion_time,
    AVG(total_cycle_time_days) AS avg_total_time
FROM fact_exam_requests
WHERE completed_date >= CURRENT_DATE() - 90;

-- SLA compliance rate
SELECT
    COUNT(*) AS total_requests,
    SUM(CASE WHEN sla_met = TRUE THEN 1 ELSE 0 END) AS met_sla,
    ROUND(SUM(CASE WHEN sla_met = TRUE THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS sla_rate_percent
FROM fact_exam_requests
WHERE completed_date >= CURRENT_DATE() - 30;

-- Identify bottlenecks
SELECT
    CASE
        WHEN days_request_to_assigned > 3 THEN 'Assignment Bottleneck'
        WHEN days_assigned_to_scheduled > 7 THEN 'Scheduling Bottleneck'
        WHEN days_scheduled_to_completed > 14 THEN 'Completion Bottleneck'
        ELSE 'No Bottleneck'
    END AS bottleneck_type,
    COUNT(*) AS request_count
FROM fact_exam_requests
WHERE exam_status = 'COMPLETED'
  AND completed_date >= CURRENT_DATE() - 90
GROUP BY bottleneck_type;
```

### VES Example: fact_claim_status

**Business Process:** Disability claim processing

**Stages:**
1. Claim filed
2. Claim received by VA
3. Evidence gathering started
4. Evidence gathering completed
5. Rating decision made
6. Decision notification sent
7. Claim closed

```sql
CREATE TABLE fact_claim_status (
    claim_status_sk NUMBER(38,0) PRIMARY KEY,

    -- Multiple date FKs (one per milestone)
    filed_date_sk NUMBER(38,0) NOT NULL,
    received_date_sk NUMBER(38,0),
    evidence_start_date_sk NUMBER(38,0),
    evidence_complete_date_sk NUMBER(38,0),
    decision_date_sk NUMBER(38,0),
    notification_date_sk NUMBER(38,0),
    closed_date_sk NUMBER(38,0),

    -- Dimensions
    veteran_sk NUMBER(38,0) NOT NULL,
    claim_sk NUMBER(38,0) NOT NULL,

    -- Actual dates
    filed_date DATE NOT NULL,
    received_date DATE,
    evidence_start_date DATE,
    evidence_complete_date DATE,
    decision_date DATE,
    notification_date DATE,
    closed_date DATE,

    -- Current status
    claim_phase VARCHAR(50),

    -- Lag facts
    days_filed_to_received NUMBER(5,0),
    days_evidence_gathering NUMBER(5,0),
    days_decision NUMBER(5,0),
    total_processing_days NUMBER(5,0),

    -- Audit
    row_updated_timestamp TIMESTAMP_NTZ
);
```

### When to Use Accumulating Snapshots

‚úÖ **Use when:**
- Process has well-defined stages/milestones
- You need to track time through each stage
- You need to identify bottlenecks in the process
- You want to calculate SLA compliance
- The process has a definite beginning and end

‚ùå **Don't use when:**
- Process has no clear stages
- Events are independent
- You need to preserve complete history of all changes (use transaction + slowly changing dimension instead)

---

## Type 4: Factless Fact Tables

### Definition

**Factless fact tables** record the **occurrence of an event** or **relationship** without any numeric measurements. They capture "what happened" or "what is related" rather than "how much."

### Characteristics

- **Grain**: One row per event/relationship
- **Updates**: Rarely updated
- **Facts**: No numeric facts! Only foreign keys
- **Queries**: "Did it happen?" or "What's covered?"

### Two Subtypes

1. **Event Tracking** - Recording that something happened
2. **Coverage/Eligibility** - Recording relationships or coverage

### VES Example: fact_veteran_enrollment (Coverage)

**Business Process:** Veteran enrolled in VA healthcare

```sql
CREATE TABLE fact_veteran_enrollment (
    enrollment_sk NUMBER(38,0) PRIMARY KEY,

    -- Dimensions (NO NUMERIC FACTS!)
    enrollment_date_sk NUMBER(38,0) NOT NULL,
    veteran_sk NUMBER(38,0) NOT NULL,
    facility_sk NUMBER(38,0) NOT NULL,
    priority_group_sk NUMBER(38,0) NOT NULL,

    -- Degenerate dimension
    enrollment_id VARCHAR(50),

    -- Flags (still not numeric measurements)
    active_flag BOOLEAN,
    enrollment_method VARCHAR(50),  -- Online, In-person, Mail

    -- Audit
    row_created_timestamp TIMESTAMP_NTZ
);
```

**Use Case:**
```sql
-- How many veterans are enrolled at each facility?
SELECT
    f.facility_name,
    COUNT(DISTINCT e.veteran_sk) AS enrolled_veterans
FROM fact_veteran_enrollment e
JOIN dim_facility f ON e.facility_sk = f.facility_sk
WHERE e.active_flag = TRUE
GROUP BY f.facility_name;

-- Which veterans are enrolled but haven't had an evaluation?
SELECT DISTINCT
    v.veteran_id,
    v.first_name,
    v.last_name
FROM fact_veteran_enrollment enroll
JOIN dim_veteran v ON enroll.veteran_sk = v.veteran_sk
LEFT JOIN fact_evaluation eval ON v.veteran_sk = eval.veteran_sk
WHERE enroll.active_flag = TRUE
  AND eval.evaluation_sk IS NULL;
```

### VES Example: fact_exam_eligibility (Coverage)

**Business Process:** Tracking which exam types a veteran is eligible for

```sql
CREATE TABLE fact_exam_eligibility (
    eligibility_sk NUMBER(38,0) PRIMARY KEY,

    -- Dimensions (NO NUMERIC FACTS!)
    effective_date_sk NUMBER(38,0) NOT NULL,
    veteran_sk NUMBER(38,0) NOT NULL,
    evaluation_type_sk NUMBER(38,0) NOT NULL,
    medical_condition_sk NUMBER(38,0),

    -- Degenerate dimensions
    eligibility_reason VARCHAR(200),    -- Why eligible

    -- Flags
    is_eligible BOOLEAN,
    requires_preauth BOOLEAN,

    -- Audit
    row_created_timestamp TIMESTAMP_NTZ
);
```

**Use Case:**
```sql
-- What exam types is veteran V123456 eligible for?
SELECT
    et.evaluation_type_name,
    mc.condition_name,
    e.eligibility_reason
FROM fact_exam_eligibility e
JOIN dim_veteran v ON e.veteran_sk = v.veteran_sk
JOIN dim_evaluation_type et ON e.evaluation_type_sk = et.evaluation_type_sk
LEFT JOIN dim_medical_condition mc ON e.medical_condition_sk = mc.medical_condition_sk
WHERE v.veteran_id = 'V123456'
  AND e.is_eligible = TRUE;
```

### When to Use Factless Facts

‚úÖ **Use when:**
- You're tracking events with no measurements
- You're tracking coverage/eligibility/relationships
- You need to answer "Did it happen?" or "Who's covered?"
- You're doing set operations (unions, intersections)

‚ùå **Don't use when:**
- You have numeric measurements (use transaction fact instead)
- You're tracking changing states (use accumulating snapshot)
- You're tracking balances over time (use periodic snapshot)

---

## Comparison Matrix

| Aspect | Transaction | Periodic Snapshot | Accumulating Snapshot | Factless |
|--------|-------------|-------------------|----------------------|----------|
| **Grain** | One event | One entity/period | One process instance | One relationship |
| **Example** | One evaluation | Daily facility metrics | One claim | One eligibility |
| **Row Count** | Very high | Predictable | Moderate | Low to moderate |
| **Updates** | Rare | Never | Frequent | Rare |
| **Date FKs** | 1 (event date) | 1 (snapshot date) | Many (per milestone) | 1 (effective date) |
| **Fact Types** | Additive, non-additive | Semi-additive | Lag times | None or boolean |
| **Query Pattern** | "What happened?" | "What was the state?" | "How long?" | "Did it happen?" |
| **VES Examples** | fact_evaluation | fact_daily_snapshot | fact_exam_requests | fact_enrollment |

---

## VES Data Warehouse Examples

### Complete Fact Table Inventory

| Fact Table | Type | Grain | Business Process |
|------------|------|-------|------------------|
| `fact_evaluation` | Transaction | One evaluation | Medical evaluation completed |
| `fact_appointment` | Transaction | One appointment | Appointment scheduled |
| `fact_appointment_events` | Transaction | One event | Appointment lifecycle event |
| `fact_evaluation_qa_events` | Transaction | One QA event | QA review performed |
| `fact_examiner_assignments` | Transaction | One assignment | Evaluator assigned to exam |
| `fact_daily_snapshot` | Periodic Snapshot | One facility/day | Daily operational metrics |
| `fact_exam_requests` | Accumulating Snapshot | One exam request | Exam request lifecycle |
| `fact_claim_status` | Accumulating Snapshot | One claim | Claim processing lifecycle |
| `fact_exam_processing_bottlenecks` | Transaction (Analysis) | One bottleneck | Bottleneck detected |

### Mixing Fact Types - Example Scenario

**Business Question:** "How long does it take from exam request to evaluation completion, and how many evaluations were performed?"

**Solution:** Use multiple fact tables together!

```sql
SELECT
    -- From accumulating snapshot: Process timing
    AVG(req.total_cycle_time_days) AS avg_days_request_to_completion,

    -- From transaction fact: Event details
    COUNT(eval.evaluation_sk) AS total_evaluations_completed,
    AVG(eval.evaluation_duration_minutes) AS avg_evaluation_minutes,
    SUM(eval.compensation_amount) AS total_compensation

FROM fact_exam_requests req
JOIN fact_evaluation eval
    ON req.veteran_sk = eval.veteran_sk
    AND req.evaluation_type_sk = eval.evaluation_type_sk
    AND eval.evaluation_date BETWEEN req.scheduled_date AND req.completed_date

WHERE req.completed_date >= CURRENT_DATE() - 90;
```

---

## Design Decision Framework

### Decision Tree

```
START: What are you measuring?

‚îú‚îÄ Is it an EVENT that happens at a point in time?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ YES ‚Üí Does it have numeric measurements?
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí **TRANSACTION FACT**
‚îÇ  ‚îÇ  ‚îÇ        Example: Each evaluation, each appointment
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí **FACTLESS FACT**
‚îÇ  ‚îÇ           Example: Enrollment, eligibility
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...

‚îú‚îÄ Is it a STATE that you want to track over TIME?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ YES ‚Üí Do you capture it at REGULAR INTERVALS?
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îú‚îÄ YES ‚Üí **PERIODIC SNAPSHOT FACT**
‚îÇ  ‚îÇ  ‚îÇ        Example: Daily facility metrics
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ NO ‚Üí Continue...

‚îú‚îÄ Is it a PROCESS with MULTIPLE STAGES?
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ YES ‚Üí **ACCUMULATING SNAPSHOT FACT**
‚îÇ           Example: Exam request, Claim processing
```

### Questions to Ask

1. **What is the business process?**
   - Evaluation conducted ‚Üí Transaction
   - Claim filed and processed ‚Üí Accumulating Snapshot
   - Daily status report ‚Üí Periodic Snapshot

2. **What is the natural grain?**
   - One per event ‚Üí Transaction
   - One per entity per period ‚Üí Periodic Snapshot
   - One per process instance ‚Üí Accumulating Snapshot

3. **How often do rows get updated?**
   - Rarely/never ‚Üí Transaction or Periodic Snapshot
   - Through lifecycle ‚Üí Accumulating Snapshot

4. **What questions need answering?**
   - "What happened?" ‚Üí Transaction
   - "What was the state?" ‚Üí Periodic Snapshot
   - "How long did it take?" ‚Üí Accumulating Snapshot
   - "Is there a relationship?" ‚Üí Factless

---

## Common Mistakes

### Mistake 1: Using Transaction When You Need Accumulating Snapshot

‚ùå **WRONG:**
```sql
-- Trying to track exam request stages with transaction facts
CREATE TABLE fact_exam_request_events (
    event_sk NUMBER PRIMARY KEY,
    exam_request_id VARCHAR(50),
    event_type VARCHAR(50),  -- 'RECEIVED', 'ASSIGNED', 'SCHEDULED', etc.
    event_date DATE
);
```

**Problem:** Hard to calculate time between stages. Need self-joins to find related events.

‚úÖ **RIGHT:**
```sql
-- Use accumulating snapshot
CREATE TABLE fact_exam_requests (
    exam_request_sk NUMBER PRIMARY KEY,
    request_date_sk NUMBER,
    assigned_date_sk NUMBER,
    scheduled_date_sk NUMBER,
    days_request_to_assigned NUMBER,  -- Easy to query!
    days_assigned_to_scheduled NUMBER
);
```

### Mistake 2: Updating Transaction Facts

‚ùå **WRONG:**
```sql
-- Updating a transaction fact (defeats the purpose!)
UPDATE fact_evaluation
SET evaluation_duration_minutes = 75
WHERE evaluation_sk = 1001;
```

**Problem:** Loses historical record. Violates transaction fact principles.

‚úÖ **RIGHT:**
```sql
-- If you need to track changes, use a separate correction table
-- Or mark original as corrected and insert new row
INSERT INTO fact_evaluation_corrections (...)
VALUES (...);
```

### Mistake 3: Too Many Date Fields in Periodic Snapshot

‚ùå **WRONG:**
```sql
CREATE TABLE fact_daily_snapshot (
    snapshot_date_sk NUMBER,
    first_appointment_date_sk NUMBER,    -- Wrong! Too granular
    last_evaluation_date_sk NUMBER,      -- Wrong! Too granular
    ...
);
```

**Problem:** Mixing event-level detail into period summary.

‚úÖ **RIGHT:**
```sql
CREATE TABLE fact_daily_snapshot (
    snapshot_date_sk NUMBER,             -- Just one date!
    appointments_today_count NUMBER,     -- Aggregate
    evaluations_today_count NUMBER       -- Aggregate
);
```

### Mistake 4: Missing Null Handling in Accumulating Snapshot

‚ùå **WRONG:**
```sql
-- Calculating lag without handling NULLs
SELECT
    DATEDIFF(day, request_date, completed_date) AS cycle_time
FROM fact_exam_requests;
-- Returns NULL for incomplete requests (can't analyze in-progress items)
```

‚úÖ **RIGHT:**
```sql
-- Handle NULLs properly
SELECT
    DATEDIFF(day, request_date,
        COALESCE(completed_date, CURRENT_DATE())) AS cycle_time_to_date
FROM fact_exam_requests;
-- OR store separate column for in-progress items
```

---

## Best Practices

### 1. Choose the Right Type

‚úÖ **DO:**
- Start with the business process
- Identify the natural grain
- Match to the appropriate pattern
- Consider query requirements

‚ùå **DON'T:**
- Force every process into transaction facts
- Mix multiple processes in one fact table
- Ignore update patterns

### 2. Name Clearly

‚úÖ **DO:**
```sql
-- Clear naming that indicates type
fact_evaluation              -- Transaction (plural OK)
fact_daily_facility_snapshot -- Periodic snapshot (include period)
fact_exam_request_status     -- Accumulating snapshot (singular)
fact_veteran_eligibility     -- Factless (relationship)
```

‚ùå **DON'T:**
```sql
-- Ambiguous naming
fact_data                    -- What data?
fact_veteran                 -- What about veteran?
fact_metrics                 -- What type of metrics?
```

### 3. Document the Grain

‚úÖ **DO:**
```sql
COMMENT ON TABLE fact_evaluation IS
    'Transaction fact table. Grain: One row per completed evaluation per medical condition.
     Type: Transaction fact. Updates: Insert-only.';
```

### 4. Handle Nulls Appropriately

**Transaction Facts:**
- Few nulls expected (event happened = all data present)

**Periodic Snapshots:**
- Nulls possible for optional dimensions
- Use 0 or default for missing measures

**Accumulating Snapshots:**
- Many nulls expected (future milestones not yet reached)
- Must handle nulls in lag calculations
- Use null-safe comparisons

### 5. Consider Performance

**Transaction Facts:**
- Partition by date for query performance
- Cluster by frequently filtered dimensions
- Archive old data if retention policy allows

**Periodic Snapshots:**
- Smaller, so less partitioning needed
- Index/cluster by snapshot date

**Accumulating Snapshots:**
- Optimize for updates (use proper keys)
- Balance between reads and writes

---

## Summary

### Key Takeaways

1. **Four types serve different purposes** - Use the right tool for the job
2. **Grain is critical** - Defines what each row represents
3. **Update patterns differ** - Transaction=rare, Periodic=never, Accumulating=frequent
4. **VES uses all types** - Real-world warehouses combine multiple patterns

### VES Fact Table Strategy

| Business Process | Fact Type | VES Example |
|------------------|-----------|-------------|
| Medical evaluations | Transaction | fact_evaluation |
| Daily operations | Periodic Snapshot | fact_daily_snapshot |
| Exam requests | Accumulating Snapshot | fact_exam_requests |
| Claims processing | Accumulating Snapshot | fact_claim_status |
| Coverage/eligibility | Factless | fact_veteran_eligibility |

### Next Steps

1. Review your business processes
2. Identify which fact type fits each process
3. Design fact tables with appropriate grain
4. Implement with proper update patterns
5. Document grain and update expectations

---

## Document Information

**Author:** Mark Chappell
**Version:** 1.0
**Last Updated:** 2024-11-18
**Related Documents:**
- [DIMENSIONAL_MODEL_DOCUMENTATION.md](DIMENSIONAL_MODEL_DOCUMENTATION.md) - Complete VES data model
- [SCD_TYPE2_DESIGN_GUIDE.md](SCD_TYPE2_DESIGN_GUIDE.md) - Dimension design patterns
- [DATA_DICTIONARY.md](DATA_DICTIONARY.md) - All tables and columns

---

**Now you understand when to use each fact table type! üìä**
